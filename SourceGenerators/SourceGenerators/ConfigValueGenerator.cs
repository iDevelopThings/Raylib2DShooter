using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators;

[Generator]
[SuppressMessage("MicrosoftCodeAnalysisCorrectness", "RS1024:Symbols should be compared for equality")]
public class ConfigValueGenerator : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        // Collect all fields with the ConfigValueAttribute
        var provider = context.SyntaxProvider
           .CreateSyntaxProvider(
                predicate: static (node, _) => node is FieldDeclarationSyntax,
                transform: static (ctx,  _) => GetSemanticTarget(ctx))
           .Where(static field => field is not null);

        var src = context.CompilationProvider.Combine(provider.Collect());

        // Combine all class definitions and execute the generation
        context.RegisterSourceOutput(src, (ctx, pair) => {
            var compilation = pair.Left;
            var fields      = pair.Right;

            var groupedFields = fields
               .OfType<FieldDef>()
               .GroupBy(field => field.ContainingClassSymbol);

            foreach (var group in groupedFields) {
                var classSymbol = group.Key;
                var source      = GenerateClassCode(classSymbol, group);
                ctx.AddSource($"{classSymbol.Name}_Generated.cs", SourceText.From(source, Encoding.UTF8));
            }
        });
    }

    private static FieldDef? GetSemanticTarget(GeneratorSyntaxContext context) {
        if (context.Node is not FieldDeclarationSyntax fieldSyntax ||
            fieldSyntax.AttributeLists.Count == 0)
            return null;

        var fieldSymbol = context.SemanticModel.GetDeclaredSymbol(fieldSyntax.Declaration.Variables.First()) as IFieldSymbol;
        if (fieldSymbol is null)
            return null;

        var allAttrNames = fieldSymbol.GetAttributes().Select(attr => attr.AttributeClass?.ToDisplayString()).ToList();
        var hasConfigValueAttribute = fieldSymbol.GetAttributes()
           .Any(attr => attr.AttributeClass?.Name == "ConfigValueAttribute");

        if (!hasConfigValueAttribute)
            return null;

        var containingClass = fieldSymbol.ContainingType;

        if (!IsConfigBase(containingClass))
            return null;

        return new FieldDef(fieldSymbol, containingClass);
    }

    private static bool IsConfigBase(INamedTypeSymbol? classSymbol) {
        while (classSymbol != null) {
            if (classSymbol is {Name: "ConfigBase", IsGenericType: true})
                return true;

            classSymbol = classSymbol.BaseType;
        }

        return false;
    }

    private static string GenerateClassCode(INamedTypeSymbol classSymbol, IEnumerable<FieldDef> fields) {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className     = classSymbol.Name;

        var sb = new StringBuilder();

        var indent = 0;

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System.ComponentModel;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");

        sb.AppendLine($"partial class {className} {{");
        sb.AppendLine();

        indent++;
        sb.AppendIndented(indent, b => {

            foreach (var f in fields) {
                GeneratePropertyCode(f, b, indent + 1);
                b.AppendLine();
            }

        });

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GeneratePropertyCode(FieldDef field, StringBuilder sb, int indent) {
        var fieldName    = field.Symbol.Name;
        var propertyName = Char.ToUpper(fieldName[1]) + fieldName.Substring(2); // Convert _fieldName to FieldName
        var fieldType    = field.Symbol.Type.ToDisplayString();
        // var defaultValueAttribute = field.Symbol.GetAttributes().FirstOrDefault(attr => attr.AttributeClass?.Name == "DefaultValueAttribute");
        // string defaultValue = "";
        // if (defaultValueAttribute?.ConstructorArguments.Length > 0) {
        // defaultValue = $"[DefaultValue({defaultValueAttribute.ConstructorArguments[0]})]";
        // }

        // sb.AppendIndentedLine(defaultValue, indent);
        sb.AppendIndentedLine($"public static {fieldType} {propertyName}", indent);
        sb.AppendIndentedLine("{", indent);
        sb.AppendIndentedLine("get => Instance." + fieldName + ";", indent + 1);
        sb.AppendIndentedLine("set => Instance.SetField(ref Instance." + fieldName + ", value);", indent + 1);
        sb.AppendIndentedLine("}", indent);

    }


}