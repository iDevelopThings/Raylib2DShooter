using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators;

[Generator]
[SuppressMessage("MicrosoftCodeAnalysisCorrectness", "RS1024:Symbols should be compared for equality")]
public class EventListenerSourceGenerators : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        var provider = context.SyntaxProvider
           .CreateSyntaxProvider(
                predicate: static (node, _) => node is FieldDeclarationSyntax,
                transform: static (ctx,  _) => GetSemanticTarget(ctx))
           .Where(static field => field is not null);

        var src = context.CompilationProvider.Combine(provider.Collect());

        // Combine all class definitions and execute the generation
        context.RegisterSourceOutput(src, (ctx, pair) => {
            var compilation = pair.Left;
            var fields      = pair.Right;

            var groupedFields = fields
               .OfType<FieldDef>()
               .GroupBy(field => field.ContainingClassSymbol);

            foreach (var group in groupedFields) {
                var classSymbol = group.Key;
                var source      = GenerateClassCode(classSymbol, group);
                ctx.AddSource($"{classSymbol.Name}_Generated.cs", SourceText.From(source, Encoding.UTF8));
            }
        });
    }

    private static FieldDef? GetSemanticTarget(GeneratorSyntaxContext context) {
        if (context.Node is not FieldDeclarationSyntax fieldSyntax ||
            fieldSyntax.AttributeLists.Count == 0)
            return null;

        var fieldSymbol = context.SemanticModel
           .GetDeclaredSymbol(fieldSyntax.Declaration.Variables.First()) as IFieldSymbol;
        if (fieldSymbol is null)
            return null;

        var hasAttr = fieldSymbol.GetAttributes()
           .Any(attr => attr.AttributeClass?.Name is "EventHandlerAttribute" or "EventHandler");
        if (!hasAttr)
            return null;

        var containingClass = fieldSymbol.ContainingType;

        return new FieldDef(fieldSymbol, containingClass);
    }

    private static string GenerateClassCode(INamedTypeSymbol classSymbol, IEnumerable<FieldDef> fields) {


        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className     = classSymbol.Name;

        var sb = new StringBuilder();

        var indent = 0;

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using RLShooter.App.Events;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();

        sb.AppendLine($"public partial class {className} {{");
        sb.AppendLine();

        indent++;
        sb.AppendIndented(indent, b => {

            foreach (var f in fields) {
                GeneratePropertyCode(f, b, indent + 1);
                b.AppendLine();
            }

        });

        sb.AppendLine("}");

        return sb.ToString();
    }
    private static string ToPascalCase(string value) {
        if (string.IsNullOrEmpty(value)) return value;
        return char.ToUpper(value[0]) + value.Substring(1);
    }
    private static void GeneratePropertyCode(FieldDef field, StringBuilder sb, int indent) {
        var fieldSymbol = field.Symbol;
        var attributeData = fieldSymbol.GetAttributes()
           .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "EventHandlerAttribute");

        var fieldName = fieldSymbol.Name;
        // var genericArgs = fieldSymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
        // .Substring("EventHandlers<".Length).TrimEnd('>');

        var fieldType = (fieldSymbol.Type as INamedTypeSymbol)!;

        var genericParams = string.Join(
            ", ",
            fieldType.TypeArguments.Select(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
        );

        var customEventName = attributeData?.ConstructorArguments.FirstOrDefault().Value as string;

        var eventName = customEventName ?? ToPascalCase(
            fieldName.Replace("Listeners", "")
        );

        sb.AppendIndentedLine($"public event EventHandler<{genericParams}> {eventName}", indent);
        sb.AppendIndentedLine("{", indent);
        sb.AppendIndentedLine($"add => {fieldName}.AddHandler(value);", indent + 1);
        sb.AppendIndentedLine($"remove => {fieldName}.RemoveHandler(value);", indent + 1);
        sb.AppendIndentedLine("}", indent);

    }


}
/*[Generator]
public class EventListenerSourceGenerators : ISourceGenerator {
    public void Initialize(GeneratorInitializationContext context) {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context) {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            return;

        var compilation = context.Compilation;

        foreach (var field in receiver.CandidateFields) {
            var semanticModel = compilation.GetSemanticModel(field.SyntaxTree);
            var fieldSymbol   = semanticModel.GetDeclaredSymbol(field) as IFieldSymbol;

            if (fieldSymbol == null)
                continue;

            var hasEventHandlerAttr = fieldSymbol.GetAttributes().Any(a => {
                var c = a.AttributeClass?.ToDisplayString();
                return c is "EventHandlerAttribute" or "EventHandler";
            });

            if (!hasEventHandlerAttr) {
                continue;
            }

            var attributeData = fieldSymbol.GetAttributes()
               .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "EventHandlerAttribute");

            var fieldName = fieldSymbol.Name;
            var genericArgs = fieldSymbol.Type.ToDisplayString()
               .Substring("EventHandlers<".Length).TrimEnd('>');
            var customEventName = attributeData?.ConstructorArguments.FirstOrDefault().Value as string;

            var eventName     = customEventName ?? ToPascalCase(fieldName.Replace("Listeners", ""));
            var generatedCode = GenerateEventCode(fieldName, eventName, genericArgs);

            context.AddSource($"{eventName}EventHandler.g.cs", generatedCode);
        }
    }

    private string GenerateEventCode(string fieldName, string eventName, string genericArgs) {
        var builder = new StringBuilder();

        builder.AppendLine("using System;");
        builder.AppendLine();
        builder.AppendLine("// Auto-generated code");
        builder.AppendLine("namespace GeneratedEventHandlers");
        builder.AppendLine("{");
        builder.AppendLine($"    public partial class {eventName}Handler");
        builder.AppendLine("    {");
        builder.AppendLine($"        public event EventHandler<{genericArgs}> {eventName}");
        builder.AppendLine("        {");
        builder.AppendLine($"            add => {fieldName}.AddHandler(value);");
        builder.AppendLine($"            remove => {fieldName}.RemoveHandler(value);");
        builder.AppendLine("        }");
        builder.AppendLine("    }");
        builder.AppendLine("}");

        return builder.ToString();
    }


    class SyntaxReceiver : ISyntaxReceiver {
        public List<FieldDeclarationSyntax> CandidateFields { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode) {
            if (syntaxNode is FieldDeclarationSyntax fieldDeclaration &&
                fieldDeclaration.AttributeLists.Any()) {
                CandidateFields.Add(fieldDeclaration);
            }
        }
    }
}*/